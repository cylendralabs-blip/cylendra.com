/**
 * Strategy Interface
 * 
 * Base interface for all trading strategies
 * Phase 4: Strategy Engine
 */

import { Candle } from '@/services/marketData/types.ts';
import { TechnicalIndicatorData } from '@/core/engines/indicatorEngine.ts';
import { BotSettingsForm } from '@/core/config';
import { Position } from '@/core/models/Position.ts';
import { Trade } from '@/core/models/Trade.ts';

/**
 * Strategy Context
 * 
 * Context provided to strategies for signal generation
 */
export interface StrategyContext {
  // Market data
  symbol: string;
  timeframe: string;
  candles: Candle[];
  currentPrice: number;
  
  // Indicators
  indicators: TechnicalIndicatorData;
  
  // Bot settings
  botSettings: BotSettingsForm;
  
  // Position/Trade info
  lastSignals: GeneratedSignal[];
  openPositions: Position[];
  openTrades: Trade[];
  
  // Risk snapshot (basic)
  activeTradesCount: number;
  totalExposure: number;
  availableBalance: number;
  
  // Portfolio snapshot (optional)
  portfolioSnapshot?: {
    totalBalance: number;
    usdBalance: number;
    positions: number;
  };
  
  // Risk snapshot (basic)
  riskSnapshot?: {
    maxActiveTrades: number;
    riskPerTrade: number;
    dailyLossLimit?: number;
  };
  
  // Exchange info
  exchange: 'binance' | 'okx';
  marketType: 'spot' | 'futures';
}

/**
 * Generated Signal
 * 
 * Signal generated by strategy
 */
export interface GeneratedSignal {
  user_id: string;
  source: 'internal_engine';
  symbol: string;
  side: 'buy' | 'sell';
  timeframe: string;
  price_at_signal: number;
  confidence: number; // 0-100
  riskLevel: 'LOW' | 'MEDIUM' | 'HIGH';
  reason: string;
  meta: {
    strategyId: string;
    strategyName: string;
    indicatorsSnapshot: TechnicalIndicatorData;
    confidenceFactors: {
      rsi: number;
      macd: number;
      trend: number;
      volume: number;
      pattern: number;
    };
    reasoning: string[];
  };
  // Optional prices (if strategy calculates them)
  stop_loss_price?: number;
  take_profit_price?: number;
  entry_price?: number; // Usually same as price_at_signal
}

/**
 * Strategy Interface
 * 
 * All strategies must implement this interface
 */
export interface Strategy {
  /**
   * Unique strategy identifier
   */
  id: string;

  /**
   * Strategy display name
   */
  name: string;

  /**
   * Supported market types
   */
  supportsMarket: ('spot' | 'futures')[];

  /**
   * Supported timeframes
   */
  timeframes: string[];

  /**
   * Initialize strategy (optional)
   * Called once when strategy is loaded
   */
  init?(ctx: StrategyContext): Promise<void>;

  /**
   * Generate signal
   * Main method called by strategy runner
   * Returns signal or null if no signal
   */
  generateSignal(ctx: StrategyContext): Promise<GeneratedSignal | null>;

  /**
   * On position open (optional)
   * Called when a position is opened from this strategy's signal
   */
  onPositionOpen?(pos: Position, ctx: StrategyContext): Promise<void>;

  /**
   * On position close (optional)
   * Called when a position is closed from this strategy's signal
   */
  onPositionClose?(pos: Position, ctx: StrategyContext): Promise<void>;

  /**
   * Validate strategy context
   * Check if context has required data
   */
  validateContext?(ctx: StrategyContext): boolean;
}

/**
 * Strategy Configuration
 */
export interface StrategyConfig {
  enabled: boolean;
  symbols: string[];
  timeframes: string[];
  minConfidence?: number;
  maxSignalsPerDay?: number;
  cooldownMinutes?: number;
  [key: string]: any;
}

